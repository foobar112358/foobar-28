"""
Zombit pandemic
===============

The nefarious Professor Boolean is up to his usual tricks. This time he is using social engineering to achieve his
twisted goal of infecting all the rabbits and turning them into zombits! Having studied rabbits at length, he found
that rabbits have a strange quirk: when placed in a group, each rabbit nudges exactly one rabbit other than itself.
This other rabbit is chosen with uniform probability. We consider two rabbits to have socialized if either or both of
them nudged the other. (Thus many rabbits could have nudged the same rabbit, and two rabbits may have socialized twice.)
We consider two rabbits A and B to belong to the same rabbit warren if they have socialized, or if A has socialized with
a rabbit belonging to the same warren as B.

For example, suppose there were 7 rabbits in Professor Boolean's nefarious lab. We denote each rabbit using a number.
The nudges may be as follows:

1 nudges 2
2 nudges 1
3 nudges 7
4 nudges 5
5 nudges 1
6 nudges 5
7 nudges 3

This results in the rabbit warrens {1, 2, 4, 5, 6} and {3, 7}.

Professor Boolean realized that by infecting one rabbit, eventually it would infect the rest of the rabbits in the same
warren! Unfortunately, due to budget constraints he can only infect one rabbit, thus infecting only the rabbits in
one warren. He ponders, what is the expected maximum number of rabbits he could infect?

Write a function answer(n), which returns the expected maximum number of rabbits Professor Boolean can infect given n,
the number of rabbits. n will be an integer between 2 and 50 inclusive.
Give the answer as a string representing a fraction in lowest terms, in the form "numerator/denominator".
Note that the numbers may be large.

For example, if there were 4 rabbits, he could infect a maximum of 2 (when they pair up) or 4 (when they're all socialized), but the expected value is 106 / 27. Therefore the answer would be "106/27".

Languages
=========

To provide a Python solution, edit solution.py
To provide a Java solution, edit solution.java

Test cases
==========

Inputs:
    (int) n = 4
Output:
    (string) "106/27"

Inputs:
    (int) n = 2
Output:
    (string) "2/1"
"""

from math import factorial
from fractions import gcd

num_trees_for_partition = [0L,
                           0L,
                           1L,
                           8L,
                           78L,
                           944L,
                           13800L,
                           237432L,
                           4708144L,
                           105822432L,
                           2660215680L,
                           73983185000L,
                           2255828154624L,
                           74841555118992L,
                           2684366717713408L,
                           103512489775594200L,
                           4270718991667353600L,
                           187728592242564421568L,
                           8759085548690928992256L,
                           432357188322752488126152L,
                           22510748754252398927872000L,
                           1232926106158164038752479600L,
                           70864880389206811919012069376L,
                           4264956622099218989964380900408L,
                           268233854186801904661404949413888L,
                           17596516621570611723107254285860000L,
                           1202034287378796801763265196064768000L,
                           85369694212882788734452615436623131432L,
                           6294445634443154805245648414750533484544L,
                           481164307787876713983817697855811244891472L,
                           38086159100543376291945674612050231296000000L,
                           3117962569860399657478478640723143576082043800L,
                           263711778692997479722657378560127779200642842624L,
                           23019602620026625886784119896351926037410391377792L,
                           2071846675499818842878197235287956993753027358752768L,
                           192094716812399052493595004779889746503480732173125000L,
                           18331598479550821498637618387125492501532509577674752000L,
                           1799128306486873097251634624641612544680165700565794891568L,
                           181455277812927984131628207045914510546689975831530576019456L,
                           18793558774469620804251752127287685035341811749012764504838392L,
                           1997481851773698127207374504024299885204574735495384268800000000L,
                           217725066338201044536232277151749132601822287693599525820471957600L,
                           24322993207498664811770063992025908744449994272086863441366798565376L,
                           2783252962715382903543081261008995076675007754537625408175546581970408L,
                           326040422290312358312341535486741187518808190457145240569672167271170048L,
                           39078734107607748249951890474620593724028205093939481724417008016906250000L,
                           4790020369221769566925830345222465070918938379231286729520950331389352345600L,
                           600135530341228889141074788642164985737852858110856472692456945542128324281432L,
                           76819732139864778254944970153522541437430179776648013928703825117887136209567744L,
                           10041823702864167812042682621441259276711025525338945412768700983639957485080366912L,
                           1339928530680358664749551425221017908902142581750156543927120170387232522240000000000L]

bin_memoize = dict()


def n_choose_k(n, k):
    if (n, k) in bin_memoize:
        return bin_memoize[(n, k)]
    orig_n, orig_k = n, k
    if 0 <= k <= n:
        ntok = 1
        ktok = 1
        for t in xrange(1, min(k, n - k) + 1):
            ntok *= n
            ktok *= t
            n -= 1
        binomial = long(ntok // ktok)
        bin_memoize[(orig_n, orig_k)] = binomial
        return binomial
    else:
        return 0L


def product(l):
    return reduce(lambda x, y: x * y, l)


def num_ways_to_make_partition(partition):
    n = sum(partition)
    total = 1
    for part in partition:
        total *= n_choose_k(n, part)
        n -= part

    den = product([factorial(partition.count(x)) for x in set(partition)])
    return total / den


all_partitions = dict()


def make_partitions(n):
    partitions_of = list()
    partitions_of.append([()])
    partitions_of.append([(1,)])
    for num in range(2, n + 1):
        ptitions = set()
        for i in range(num):
            for partition in partitions_of[i]:
                ptitions.add(tuple(sorted((num - i,) + partition)))
        partitions_of.append(list(ptitions))
    return filter(lambda x: min(x) >= 2, partitions_of[n])


def real_answer(n):
    my_partitions = sorted(make_partitions(n))
    total_rabbits = 0
    for partition in my_partitions:
        ways_to_make_partition = num_ways_to_make_partition(partition)
        num_ways_to_make_inner_graphs = product([num_trees_for_partition[x] for x in partition])
        num_rabbits_infected = max(partition)
        total_rabbits += ways_to_make_partition * num_ways_to_make_inner_graphs * num_rabbits_infected

    total_forests = (n - 1) ** n
    my_gcd = gcd(total_rabbits, total_forests)
    total_rabbits /= my_gcd
    total_forests /= my_gcd
    return "%s/%s" % (total_rabbits, total_forests)


precompute = {
    2: "2/1",
    3: "3/1",
    4: "106/27",
    5: "155/32",
    6: "17886/3125",
    7: "38563/5832",
    8: "6152766/823543",
    9: "17494593/2097152",
    10: "3560009650/387420489",
    11: "627954547/62500000",
    12: "3105872296170/285311670611",
    13: "1634885974709/139314069504",
    14: "3806351519163438/302875106592253",
    15: "18625944786006435/1389000853194752",
    16: "6234351169555051774/437893890380859375",
    17: "34756722601614314393/2305843009213693952",
    18: "773562277426009442754/48661191875666868481",
    19: "10284482150135468731247/614787626176508399616",
    20: "34718513354331762959383530/1978419655660313589123979",
    21: "15053773537765084950812607/819200000000000000000000",
    22: "112140288809338469272615587070/5842587018385982521381124421",
    23: "854320303454493478751408480735/42678484670527444674580840448",
    24: "18912756321867471938721965101170/907846434775996175406740561329",
    25: "3610030325498948367204598852852585/166716972106285515556135184105472",
    26: "1995411155670864680670929436760622226/88817841970012523233890533447265625",
    27: "344576823778566517467992368671763089/14798364375497974304799697808654336",
    28: "10684649726223342659811498644660675608426/443426488243037769948249630619149892803",
    29: "1843103398013622761374075136603923170373/73985542663511997461099839851260280832",
    30: "66042949805511372231365213875653489838628430/2567686153161211134561828214731016126483469",
    31: "136582014642563779970541724775540053333470143/5147278302366225000000000000000000000000000",
    32: "466710421570971604568184743712738644191638213630/17069174130723235958610643029059314756044734431",
    33: "5143463407898005313442475192483802091320056485177/182687704666362864775460604089535377456991567872",
    34: "3739096410394966424064185724550288598383827338841538/129110040087761027839616029934664535539337183380513",
    35: "2734416349495925626662325797021969312293908777741055/91848741448192312589172269541487152770452671168512",
    36: "6741987061723606853594628610525741041930695353663689186/220501499870829739190357286682701669633388519287109375",
    37: "13042636517110143087176055909996022983442999225254367979/415575620795767675030130764658032788047530686054137856",
    38: "339749569462116848439935334968084869925827515702722344355358/10555134955777783414078330085995832946127396083370199442517",
    39: "4437525380892633218641214622385900021643773692787246091579511/134488975247499247757553656607015472389435921103802008076288",
    40: "3805487585436257606374152449167335438201952264350939203818892350/112595147462071192539789448988889059930192105219196517009951959",
    41: "52292042753206118664403121823278381003500114115970247032940845257/1511157274518286468382720000000000000000000000000000000000000000",
    42: "47120325153233237084737138078618913934658460950300385959724398769010/1330877630632711998713399240963346255985889330161650994325137953641",
    43: "169883796370934068081950976917114805097902708520947013505251740843915/4691591798290517886149124130132951806688999080273086788621672906752",
    44: "641905988034354231029821722880620140843980880607592490372521399462500330/17343773367030267519903781288812032158308062539012091953077767198995507",
    45: "1211700424850550781463312152848931785433758128964920752788874530817930545/32043340993134532088206337643318375554471559945634492926483077596708864",
    46: "9578738547310180405522771203581728115283009160565774924265357416769319791214/248063644451341145494649182395412689744530581492654164321720600128173828125",
    47: "151164422577241276086427256674992515031103246835103828947780587220861706128723/3835043287599284278832554205955049737473521330634856660010332469295644147712",
    48: "155952219111744763744858482987443790414475772813221572439665055721589513953631486/3877924263464448622666648186154330754898344901344205917642325627886496385062863",
    49: "2567162329457217045964642947718867244253878791072715244167941318071834302918083033/62587759782932414896817128156196361030838744422175027877657217635602709644050432",
    50: "2760193150860512039773534794580172563788128162694566629462545301385874784598772926370/66009724686219550843768321818371771650147004059278069406814190436565131829325062449",
}


def answer(n):
    # return real_answer(n)
    return precompute[n]


print(answer(4))
# for i in xrange(2, 51):
#     print('%d:"%s",' % (i, answer(i)))
